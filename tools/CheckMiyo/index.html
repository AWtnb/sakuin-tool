<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <title>見よ項目の確認</title>
    <base target="_blank">
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" type="text/css" href="../style.css">
    <style>
        .lostTo, .lostFrom {
            font-weight: bold;
            font-size: .8em;
            margin-top: 1em;
        }
    </style>
</head>

<body>
<!-- ============================== -->
<div class="container">


<h2>見よ項目の確認</h2>

<div class="ui">
    <textarea class="inputLines" placeholder="索引をコピー＆ペーストしてください"></textarea>
    <input type="button" value="チェック" onclick="click_check()">

    <div class="result">
        <div class="lostTo">
            <label>見よ項目があるのに参照先に括弧で付記されていないもの：</label>
            <div class="output"></div>
        </div>
        <div class="lostFrom">
            <label>参照元として括弧書きされているのに見よ項目がないもの：</label>
            <div class="output"></div>
        </div>
    </div>
</div>

</div>
<!-- ============================== -->
<script type="text/javascript" src="../util.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/ie-buster@1.1.0/dist/ie-buster.min.js"></script>
<script>

    function getRegex(from, to, searchingMiyo = false) {
        const f = escapeMeta(from);
        const t = escapeMeta(to);
        if (searchingMiyo) {
            return new RegExp(`${f}\\s*→\\s*${t}`);
        }
        return new RegExp(`^${t}[（［].*${f}.*[）］]`);
    }

// 見よ項目があるのに見よ先の項目に括弧書きで付記されていないものを探す関数
function findLostReferenceTo(lines) {
    const items = lines.map(line => line.replace(/　　\d.+$/, "")).filter(line => line);
    const refs = items.filter(line => line.indexOf("→") != -1);
    return refs.map(line => {
        const arr = line.split(/\s*→\s*/);
        return {
            "Text": line,
            "From": arr[0],
            "To": arr[1]
        };
    }).map(line => {
        const reg = getRegex(line.From, line.To, false)
        const grep = items.filter(l => reg.test(l));
        if (grep.length > 0) {
            return null;
        }
        return {
            "Text": line.Text,
            "Lost": `${line.To}（${line.From}）`
        }
    }).filter(x => x);
}

// 括弧書きで付記されているのに見よ項目がないものを探す関数
function findLostReferenceFrom(lines) {
    const items = lines.map(line => line.replace(/　　\d.+$/, "")).filter(line => line);
    const reffered = items.filter(line => /[［（\(].+?[］）\)]/.test(line));
    return reffered.map(line => {
        return {
            "Text": line,
            "From": line.replace(/^.+?[［（\(](.+?)[］）\)].*$/, "$1"),
            "To": line.replace(/[［（\(].+$/, "")
        };
    }).map(line => {
        const reg = getRegex(line.From, line.To, true);
        const grep = items.filter(l => reg.test(l));
        if (grep.length > 0) {
            return null;
        }
        return {
            "Text": line.Text,
            "Lost": `${line.From}　→${line.To}`
        }
    }).filter(x => x);
}

function markupLostReference(item, color = "red") {
    return `<li style="margin-left:1em"><span style="font-weight:bold">${item.Text}</span> …… <span style="color:${color}">${item.Lost}</span></li>`
}

function click_check(){
    const elem = document.querySelector(".ui");
    const arr = [];
    const lines = splitline(elem.querySelector(".inputLines").value);
    const lostTo = findLostReferenceTo(lines).map(item => markupLostReference(item, "red"));
    elem.querySelector(".result .lostTo .output").innerHTML = lostTo.join("\n");
    const lostFrom = findLostReferenceFrom(lines).map(item => markupLostReference(item, "blue"));
    elem.querySelector(".result .lostFrom .output").innerHTML = lostFrom.join("\n");
}

</script>
</body>

</html>
